
 <!DOCTYPE HTML>
<html >
<head>
  <meta charset="UTF-8">
  
    <title>[译]你该知道的javascript作用域 (javascript scope) | ittce blog</title>
    <meta name="viewport" content="width=device-width, initial-scale=1,user-scalable=no">
    
    <meta name="author" content="ittce">
    

    
    <meta name="description" content="原文地址黑哥版本1黑哥版本2javascript有一些对于初学者甚至是有经验的开发者都难以理解的概念. 这个部分是针对那些听到 : 作用域, 闭包, this, 命名空间, 函数作用域, 函数作用域, 全局作用域, 变量作用域(后续翻译这个词我也没太懂), 公共/私有 作用域 后想要深入了解的人的. 当你看完这篇文章后你将了解有关以下问题的答案: 

什么是作用域
什么是全局/局部 作用域
什么是">
<meta property="og:type" content="article">
<meta property="og:title" content="[译]你该知道的javascript作用域 (javascript scope)">
<meta property="og:url" content="http://ittce.github.io/blog/2015/05/07/javascripScope/index.html">
<meta property="og:site_name" content="ittce blog">
<meta property="og:description" content="原文地址黑哥版本1黑哥版本2javascript有一些对于初学者甚至是有经验的开发者都难以理解的概念. 这个部分是针对那些听到 : 作用域, 闭包, this, 命名空间, 函数作用域, 函数作用域, 全局作用域, 变量作用域(后续翻译这个词我也没太懂), 公共/私有 作用域 后想要深入了解的人的. 当你看完这篇文章后你将了解有关以下问题的答案: 

什么是作用域
什么是全局/局部 作用域
什么是">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="[译]你该知道的javascript作用域 (javascript scope)">
<meta name="twitter:description" content="原文地址黑哥版本1黑哥版本2javascript有一些对于初学者甚至是有经验的开发者都难以理解的概念. 这个部分是针对那些听到 : 作用域, 闭包, this, 命名空间, 函数作用域, 函数作用域, 全局作用域, 变量作用域(后续翻译这个词我也没太懂), 公共/私有 作用域 后想要深入了解的人的. 当你看完这篇文章后你将了解有关以下问题的答案: 

什么是作用域
什么是全局/局部 作用域
什么是">

    
    <link rel="alternative" href="/atom.xml" title="ittce blog" type="application/atom+xml">
    
    
    <link rel="icon" href="/blog/img/favicon.ico">
    
    
    <link rel="apple-touch-icon" href="/blog/img/jacman.jpg">
    <link rel="apple-touch-icon-precomposed" href="/blog/img/jacman.jpg">
    
    <link rel="stylesheet" href="/blog/css/style.css" type="text/css">
</head>

  <body>
    <header>
      
<div>
		
			<div id="imglogo">
				<a href="/blog/"><img src="/blog/img/logo.png" alt="ittce blog" title="ittce blog"/></a>
			</div>
			
			<div id="textlogo">
				<h1 class="site-name"><a href="/blog/" title="ittce blog">ittce blog</a></h1>
				<h2 class="blog-motto">The most difficult thing is the decision to act, the rest is merely tenacity.</h2>
			</div>
			<div class="navbar"><a class="navbutton navmobile" href="#" title="菜單">
			</a></div>
			<nav class="animated">
				<ul>
					<ul>
					 
						<li><a href="/blog/">首页</a></li>
					
						<li><a href="/blog/archives">文章列表</a></li>
					
						<li><a href="/blog/about">关于我</a></li>
					
					<li>
 					
					<form class="search" action="//google.com/search" method="get" accept-charset="utf-8">
						<label>Search</label>
						<input type="search" id="search" name="q" autocomplete="off" maxlength="20" placeholder="搜索" />
						<input type="hidden" name="q" value="site:ittce.github.io/blog">
					</form>
					
					</li>
				</ul>
			</nav>			
</div>
    </header>
    <div id="container">
      <div id="main" class="post" itemscope itemprop="blogPost">
  
	<article itemprop="articleBody"> 
		<header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/blog/2015/05/07/javascripScope/" title="[译]你该知道的javascript作用域 (javascript scope)" itemprop="url">[译]你该知道的javascript作用域 (javascript scope)</a>
  </h1>
  <p class="article-author">By
       
		<a href="/blog/about" title="ittce" target="_blank" itemprop="author">ittce</a>
		
  <p class="article-time">
    <time datetime="2015-05-07T03:28:35.000Z" itemprop="datePublished"> 發表於 2015-05-07</time>
    
  </p>
</header>
	<div class="article-content">
		
		<div id="toc" class="toc-article">
			<strong class="toc-title">文章目錄</strong>
		
			<ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#什么是作用域_?"><span class="toc-number">1.</span> <span class="toc-text">什么是作用域 ?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#什么是全局作用域_?"><span class="toc-number">2.</span> <span class="toc-text">什么是全局作用域 ?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#什么是局部作用域_?"><span class="toc-number">3.</span> <span class="toc-text">什么是局部作用域 ?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#函数作用域"><span class="toc-number">4.</span> <span class="toc-text">函数作用域</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#词法作用域(_Lexical_scope_)"><span class="toc-number">5.</span> <span class="toc-text">词法作用域( Lexical scope )</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#作用域链"><span class="toc-number">6.</span> <span class="toc-text">作用域链</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#闭包"><span class="toc-number">7.</span> <span class="toc-text">闭包</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#作用域_和_this"><span class="toc-number">8.</span> <span class="toc-text">作用域 和 this</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#使用_apply(),_call(),_bind()_修改作用域"><span class="toc-number">9.</span> <span class="toc-text">使用 apply(), call(), bind() 修改作用域</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#call()_&&_apply()"><span class="toc-number">9.1.</span> <span class="toc-text">call() && apply()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#bind()"><span class="toc-number">9.2.</span> <span class="toc-text">bind()</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#私有和公共作用域"><span class="toc-number">10.</span> <span class="toc-text">私有和公共作用域</span></a></li></ol>
		
		</div>
		
		<p><a href="http://toddmotto.com/everything-you-wanted-to-know-about-javascript-scope/" target="_blank" rel="external">原文地址</a><br><a href="http://www.heibaipig.com/blog/?p=292" target="_blank" rel="external">黑哥版本1</a><br><a href="http://www.heibaipig.com/blog/?p=313" target="_blank" rel="external">黑哥版本2</a><br>javascript有一些对于初学者甚至是有经验的开发者都难以理解的概念. 这个部分是针对那些听到 : 作用域, 闭包, this, 命名空间, 函数作用域, 函数作用域, 全局作用域, 变量作用域(后续翻译这个词我也没太懂), 公共/私有 作用域 后想要深入了解的人的. 当你看完这篇文章后你将了解有关以下问题的答案: </p>
<ul>
<li>什么是作用域</li>
<li>什么是全局/局部 作用域</li>
<li>什么是命名空间,他和作用域的不同</li>
<li>this是什么,它是怎样被作用域影响的</li>
<li>什么是函数/lexical 作用域</li>
<li>什么是闭包</li>
<li>什么是公共/私有 作用域</li>
<li>我们如何了解/创建/使用 以上的概念</li>
</ul>
<h3 id="什么是作用域_?">什么是作用域 ?</h3><p>在javasript中, 作用域指你的代码当前的上下文. 作用域有全局和局部的区别. 了解javascript作用域是你书写出更健壮的代码和成为更好的开发者的钥匙. 你将了解变量/函数 在那里是可访问的, 改变你的代码的作用域, 并且更快的写出更易于维护和调试的代码.思考作用域是很容易的, 我们是在作用A 或 作用域B的内部</p>
<h3 id="什么是全局作用域_?">什么是全局作用域 ?</h3><p>当你写下一行代码之前, 你就在我们叫做全局作用域里 ; 如果此时我们声明(declare)一个变量(variable), 那他默认就是全局的( globally ).<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//全局作用域 global scope</span></span><br><span class="line"><span class="keyword">var</span> name = <span class="string">"Todd"</span></span><br></pre></td></tr></table></figure></p>
<p>全局作用域是你最好朋友, 同时也是你的噩梦,学习控制作用域是容易的, 这样做你将避免在全局作用域中运行时的问题(通常是命名空间冲突);你经常听说’全局作用域是不好的’, 但是没有人证明为什么. 全局作用域不是坏的, 你需要通过它创建可访问的 Modules/APIs, 你必须使用并发挥它的优势, 确保不会出现问题.</p>
<p>任何人使用jQuery的时候要这样做:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jQuery(<span class="string">'.myClass'</span>)</span><br></pre></td></tr></table></figure></p>
<p>我们在全局作用域访问jQuery, 我们可以参考此次访问的命名空间. 命名空间偶尔作为一个作用域使用, 但是通常是指那些最顶级的作用域. 在这个例子里, jQuery在全局作用域中, 但是也是我们的命名空间. 这个jQuery的命名空间默认的存在在全局作用域下, 它充当了jQuery库的命名空间, 在它内部的所有东西充当了这个命名空间的后代. </p>
<h3 id="什么是局部作用域_?">什么是局部作用域 ?</h3><p>局部作用域是指在全局作用域内部定义(defined:定义, default:默认)的作用域. 通常在一个全局作用域内定义的任何一个函数都有自身的局部作用域. 在函数内部定义的函数也拥有一个看起来像外部函数的局部作用域. 如果我们在一个函数内部定义了变量,那么这些函数的作用域就在函数内部. 像这个例子 :<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">//Scope A : global scope out here </span></span><br><span class="line">  <span class="keyword">var</span> myFuntion = <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//ScopeB : local scope in here</span></span><br><span class="line">  &#125;</span><br><span class="line"><span class="string">``</span><span class="string">` </span><br><span class="line">除非暴漏出来,否则局部作用域成员在全局作用域内是不可见的. 意思是如果我们定义一些函数和变量在一个新的作用域内, 在这个作用域外它是不可访问的. 一个简单的例子如下 : </span><br><span class="line">`</span><span class="string">``</span>js</span><br><span class="line">  <span class="keyword">var</span> myFunction = <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> name = <span class="string">"ittce"</span>;</span><br><span class="line">    <span class="built_in">console</span>.log( name );</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.log( name );<span class="comment">// Uncaught ReferenceError: name is not defined</span></span><br></pre></td></tr></table></figure></p>
<p>这个变量name在局部作用域内, 它没有暴漏在父级作用域内, 因此显示未定义.</p>
<h3 id="函数作用域">函数作用域</h3><p>javascript中的所有作用域只能靠函数创建, 不能靠for/while 循环或者表达式声明(if, switch)来创建. 新函数 = 新作用域, 这是规矩.一个例子来演示作用域的创建:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Scope A</span></span><br><span class="line"><span class="keyword">var</span> myFunction = <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">//Scope B</span></span><br><span class="line">  <span class="keyword">var</span> muOtherFunction = <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//Scope C</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>创建一个局部作用域和局部 变量/函数/对象 是很容易的. </p>
<h3 id="词法作用域(_Lexical_scope_)">词法作用域( Lexical scope )</h3><p>当你看到一个函数在另外一个函数内部, 内部函数可以访问到外部函数的作用域, 它被叫做词法作用域 或 闭包, 也被称为静态作用域.下面是一个最容易的演示例子:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Scope A</span></span><br><span class="line"><span class="keyword">var</span> myFunction = <span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="comment">//Scope B</span></span><br><span class="line">  <span class="keyword">var</span> name = <span class="string">"ittce"</span>; <span class="comment">// defined in Scope B</span></span><br><span class="line">  <span class="keyword">var</span> myOtherFunction = <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//Scope C : name is accessible here ! name 可以在这里访问到</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>你发现 myOtherFunction 在这里不应该被这样叫, 它只是简单的定义在这里. 调用命令也会引起变量和作用域的反应, 这里我定义我的函数并调用它在另外一个console的下面 :<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myFunction = <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> name =<span class="string">"ittce"</span>;</span><br><span class="line">  <span class="keyword">var</span> myOtherFunction = <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"My name is"</span> + name );</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.log( name );</span><br><span class="line">  myOtherFunction();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 将要输出:</span></span><br><span class="line"><span class="comment">// ittce</span></span><br><span class="line"><span class="comment">// My name is ittce</span></span><br></pre></td></tr></table></figure></p>
<p>词法作用域是易于使用的, 任何定义于它作用域链顶端的变量/函数/对象,在它的作用域内都是可用的.像这个例子:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">'ittce'</span>;</span><br><span class="line"><span class="keyword">var</span> scope1 = <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// name is available here  name 在这里是可用的</span></span><br><span class="line">  <span class="keyword">var</span> scope2 = <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// name is  available here too</span></span><br><span class="line">    <span class="keyword">var</span> scope3 = <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="comment">// name is also available here</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里最重要的是记得词法作用域是不可逆的. 这里我们可以看到为什么词法作用域不可访问 :<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// name = undefined</span></span><br><span class="line"><span class="keyword">var</span> scope1 = <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// name = undefined</span></span><br><span class="line">  <span class="keyword">var</span> scope2 = <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// name = undefined</span></span><br><span class="line">    <span class="keyword">var</span> scope3 = <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">var</span> name = <span class="string">'ittce'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我可以总是返回name的一个引用, 但是并不是它自身.</p>
<h3 id="作用域链">作用域链</h3><p>作用域链建立在一个特定的函数作用域之上. 定义的每个函数都有它自身的作用域嵌套, 因此我们知道, 定义在另一个函数内部的函数拥有一个和外部函数联系的局部作用域, 这种联系我们叫做链. 它总是有一个位置在那个确定的作用域内. 当开始解析一个变量, javascript会从最内部的作用域逐层向外查找直到找到这个变量/对象/函数, 或没找到返回undefined错误.</p>
<h3 id="闭包">闭包</h3><p>闭包和词法作用域的联系非常密切, 一个更好的例子去演示闭包如何工作, 一个实际例子如下,当函数内部返回另一个函数的引用时.在父作用域内, 我们可以访问到内部作用域返回的东西 :<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> sayHello = <span class="function"><span class="keyword">function</span> <span class="params">( name )</span> </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> text = <span class="string">"hello,"</span> + name ();</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log( text );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>闭包概念可以使我们内部作用域的东西私有化,无法被外部作用域所访问. 当我们单独调用这个函数时, 他将不做任何事, 因为它返回的是一个函数<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sayHello( <span class="string">'ittce'</span> );<span class="comment">// 没有事情发生, 也不报错, 只有沉默</span></span><br></pre></td></tr></table></figure></p>
<p>该函数返回一个函数, 这意味着它需要分配, 然后再次调用 :<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> helloIttce = sayHello( <span class="string">'ittce'</span> );</span><br><span class="line">helloIttce(); <span class="comment">// will call the closure and log 'hello, ittce';</span></span><br></pre></td></tr></table></figure></p>
<p>好的, 我说谎了, 你可以不用分配就调用它, 你可以能已经看到过这种调用闭包的方式 :<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sayHello( <span class="string">'ittce'</span> )();</span><br></pre></td></tr></table></figure></p>
<p>AngularJS中的 $.compile 使用了以上的技术在闭包中传递当前的作用域引用 :<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">  $.compile( template )( scope );</span><br><span class="line"><span class="string">``</span><span class="string">` </span><br><span class="line">意思是我们可以猜到它内部的代码简化版本像这样:</span><br><span class="line">`</span><span class="string">``</span>js</span><br><span class="line">  <span class="keyword">var</span> $compile = <span class="function"><span class="keyword">function</span> <span class="params">( template )</span> </span>&#123;</span><br><span class="line">    <span class="comment">// some magic stuff here</span></span><br><span class="line">    <span class="comment">// scope is out of scope, though...</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="params">( scope )</span></span>&#123;</span><br><span class="line">      <span class="comment">// access to `template` and `scope` to do magic with too</span></span><br><span class="line">      <span class="comment">// 这里仍然可以访问到 'template' 和 'scope' 做我们想做的事情</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<p>一个函数不需要返回一个调用闭包的命令也可以调用闭包. 简单的直接访问外部变量的词法作用域来创建一个闭包. </p>
<h3 id="作用域_和_this">作用域 和 this</h3><p>依据函数如何被调用给this绑定一个不同的作用域. 我们都使用过this, 但并不都了解它被调用时的不同. 在客户端默认的this指向最外部的全局对象, window. 我们很容易发现在不同的调用方式下, this具有不同的值 :<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myFunction = <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log( <span class="keyword">this</span> ) <span class="comment">// this 这是是全局对象 window</span></span><br><span class="line">&#125;</span><br><span class="line">myFunction();</span><br><span class="line"><span class="keyword">var</span> myObject = &#123;&#125;;</span><br><span class="line">myObject.myMethod = <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log( <span class="keyword">this</span> ) <span class="comment">// this 这里指向 对象 myObject</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> nav = <span class="built_in">document</span>.querySelector(<span class="string">'.nav'</span>);</span><br><span class="line"><span class="keyword">var</span> toggleNav = <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log( <span class="keyword">this</span> );</span><br><span class="line">&#125;</span><br><span class="line">nav.addEventListener(<span class="string">'click'</span>, toggleNav, <span class="literal">false</span> );  <span class="comment">// 这里调用函数时, this 指向 .nav 这个DOM element</span></span><br></pre></td></tr></table></figure></p>
<p>当我们使用this时, 也会经常出现问题. 例如像下面这样, 甚至在相似的函数内部那些作用域和this的值都可以被改变的:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> nav = <span class="built_in">document</span>.querySelector(<span class="string">'.nav'</span>);</span><br><span class="line"><span class="keyword">var</span> toggleNav = <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log( <span class="keyword">this</span> ); <span class="comment">// nav element</span></span><br><span class="line">  setTimeout( <span class="function"><span class="keyword">function</span> <span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log( <span class="keyword">this</span> ); <span class="comment">// window</span></span><br><span class="line">  &#125;, <span class="number">500</span> );</span><br><span class="line">&#125;;</span><br><span class="line">nav.addEventListener(<span class="string">'click'</span>, toggleNav, <span class="literal">false</span> );</span><br></pre></td></tr></table></figure></p>
<p>这里发生了什么呢 ? 我们创建了一个不调用我们事件处理程序的新的作用域, 因此他像预期的那样指向了全局作用域: window. 有几种方法可以让this不受新作用域的影响, 像我们预期的那样工作. 你可以已经了解过这个, 我们可以使用一个 that 变量缓存this的引用 :<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> nav = <span class="built_in">document</span>.querySelector( <span class="string">'.nav'</span> );</span><br><span class="line"><span class="keyword">var</span> toggleNav = <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> that = <span class="keyword">this</span>;</span><br><span class="line">  setTimeout( <span class="function"><span class="keyword">function</span> <span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log( that );</span><br><span class="line">  &#125;, <span class="number">500</span>);</span><br><span class="line">&#125;;</span><br><span class="line">nav.addEventListener(<span class="string">'click'</span>, toggleNav, <span class="literal">false</span> );</span><br></pre></td></tr></table></figure></p>
<p>这样一个小花招可以让this在新创建的作用域内按我们预期的那样指向正确的值. </p>
<h3 id="使用_apply(),_call(),_bind()_修改作用域">使用 apply(), call(), bind() 修改作用域</h3><p>有时你需要操纵javascript作用域像你想的那样工作. 一个简单的例子来演示在循环中, 作用域是怎么改变的:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> links = <span class="built_in">document</span>.querySelectorAll(<span class="string">'a'</span>);</span><br><span class="line"><span class="keyword">for</span> ( <span class="keyword">var</span> i = <span class="number">0</span>; i &lt; links.length; i++ )&#123;</span><br><span class="line">  <span class="built_in">console</span>.log( <span class="keyword">this</span> ); <span class="comment">// this = window</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里this的值不指向我们的DOM节点, 我们没有调用任何东西或者改变作用域. 让我们看下我们如何修改作用域( 它看起来像是我们改变了作用域, 其实是改变了函数被调用时的上下文执行环境 ).</p>
<h4 id="call()_&amp;&amp;_apply()">call() &amp;&amp; apply()</h4><p>call() &amp;&amp; apply() 方法真的很棒, 它可以允许你传递一个绑定正确this的作用域给函数. 让我们操作以上的函数, 让他们的this指向各自的在数组中DOM节点 :<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> links = <span class="built_in">document</span>.querySelectorAll( <span class="string">'a'</span> );</span><br><span class="line"><span class="keyword">for</span> ( <span class="keyword">var</span> i = <span class="number">0</span>; i &lt; links.length; i++ ) &#123;</span><br><span class="line">  ( <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log( <span class="keyword">this</span> );</span><br><span class="line">  &#125;).call( links[i] );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>你可以看到我们传递传递在数组中迭代的当前的节点: links[i], 这改变了函数的作用域, 使this指向了迭代的DOM节点. 如果我们需要的话, 我们可以使用这个this. 我们可以使用call()  &amp;&amp; apply() 来改变函数的作用域, 但是更进一步的参数传递两者有区别 : call( scope, arg1, arg2 )需要单个的用参数, 使用逗号分隔 ; apply( scope, [ agr1, agr2] )接受一个参数数组.重要的是要记住: 使用 apply() 或 call()时实际上调用了函数,因此不要这样:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">myFunction();</span><br></pre></td></tr></table></figure></p>
<p>你需要用.call()处理它,并链接到这个方法<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">myFunction.call();</span><br></pre></td></tr></table></figure></p>
<h4 id="bind()">bind()</h4><p>不向上面一样, 使用 .bind() 不会调用函数, 它仅仅是在函数被调用之前绑定值.这个方法在ECMAScipt5中才被引入真是一个耻辱,因为它实在太棒了. 你知道在函数引用时我们不能够传递参数, 像这样 :<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//工作</span></span><br><span class="line">nav.addEventListener(<span class="string">'click'</span>, toggleNav, <span class="literal">false</span> );</span><br><span class="line"><span class="comment">//立刻执行</span></span><br><span class="line">nav.addEventListener(<span class="string">'click'</span>, toggleNav( arg1, agr2 ), <span class="literal">false</span> );</span><br></pre></td></tr></table></figure></p>
<p>我们可以解决这个问题, 但是需要在它里面创建一个新的函数 :<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">nav.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">  toggleNav( arg1, agr2 );</span><br><span class="line">&#125;, <span class="literal">false</span> );</span><br></pre></td></tr></table></figure></p>
<p>但是这改变了作用域并且我们创建了一个不必要的函数, 如果我们需要在循环中添加事件监听,这将是巨大的性能浪费. 这就是 .bind()闪耀的原因, 我们可以不调用函数的情况下, 传递参数给它 :<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nav.addEventListener( <span class="string">'click'</span>, toggleNav.bind( scope, arg1, arg2 ), <span class="literal">false</span> );</span><br></pre></td></tr></table></figure></p>
<p>函数没有被调用, 但是作用域已经根据需求改变, 参数坐等函数调用时传递.</p>
<h3 id="私有和公共作用域">私有和公共作用域</h3><p>在许多程序设计语言中, 你可能听说过 公共 和 私有 作用域, 但是在 javascript 中不存在这些. 可是我们可以通过闭包来模拟公共和私有作用域. 通过javascript设计模式 , 例如单例模式, 我们可以创建公共和私有作用域. 一个简单的方法去创建私有作用域, 是在我们的函数们外包一层函数. 像我们学习的那样, 函数创建的作用域内 , 可以保存东西不被外部作用域访问到 :<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">( <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 私有作用域</span></span><br><span class="line">&#125; )();</span><br></pre></td></tr></table></figure></p>
<p>我们可以在添加一些功能, 在我们的app中使用 :<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">( <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> myFunction = <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//可以在这里做一些事</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125; )()</span><br></pre></td></tr></table></figure></p>
<p>当我们调用我们的功能, 在外部作用域我们无法访问到它 :<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">( <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> myFunction = <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//可以在这里做一些事</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125; )();</span><br><span class="line">myFunction();<span class="comment">// Uncaught ReferenceError: myFunction is not defined</span></span><br></pre></td></tr></table></figure></p>
<p>成功了! 我们创建了私有作用域. 但是我想把函数公开呢 ? 这里有一个很棒的模式( 叫 模块模式 或 揭示模块模式 )允许我们的函数在作用域内正常的工作, 使用私有和公共的作用域 和一个对象. 这里我们将包含我们所有的代码的全局命名空间叫做模块.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义 module</span></span><br><span class="line"><span class="keyword">var</span> Module = (<span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    myMethod: <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'myMethod has been called.'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用 module + methods</span></span><br><span class="line">Module.myMethod();</span><br></pre></td></tr></table></figure></p>
<p>这里的 return 语句 返回我们所有可以通过命名空间访问的公共方法. 这意味到我们的模块关联到了我们的命名空间, 并且包含了我们想要的许多方法. 我们可以按照我们的希望扩展我们的模块 :<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义模块</span></span><br><span class="line"><span class="keyword">var</span> <span class="built_in">module</span> = (<span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    myMethod : <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;&#125;,</span><br><span class="line">    someOtherMethod : <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)();</span><br><span class="line"><span class="comment">// call module + methods</span></span><br><span class="line">Module.myMethod();</span><br><span class="line">Module.someOtherMethod();</span><br></pre></td></tr></table></figure></p>
<p>那么为什么使用私有方法 ? 因为很多的开发者将他们的函数放在全局作用域下污染命名空间. 函数帮助我们的代码工作, 但是并不需要将他们放在全局命名空间内, 只需要使用 API 调用就可以了. 下面是我们通过不返回函数创建的私有作用域 :<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Module = ( <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> privateMethod = <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    publicMethod : <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">      </span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure></p>
<p>这意味着 publicMethod 可以被调用, 但是 privateMethod 不可以, 因为它在私有作用域内. 这些私有作用域内的函数可以是任何你想到功能 : addClass, removeClass, Ajax/XHR calls, Arrays, Objects, helper.这是一个有趣的转折, 在同一个作用域内的东西可以访问同一作用域内的所有东西, 即使它被返回出去. 这意味着 我们公共的方法可以访问到我们私有的那些, 因此他们虽然在全局作用内不可访问, 但仍受到影响.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Module = (<span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> privateMethod = <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    publicMethod: <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="comment">// 可以访问私有方法</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure></p>
<p>这使得我们将代码的安全提升到一个更高的水平. 确保代码安全是javascript一个很重要的方面, 因此我们不能将所有的功能都放在全局作用域公开, 这样面对脆弱的攻击也是很容易攻破的. 下面是一个利用公共和私有方法, 返回一个对象的例子 :<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Module = (<span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> myModule = &#123;&#125;;</span><br><span class="line">  <span class="keyword">var</span> privateMethod = <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  &#125;;</span><br><span class="line">  myModule.publicMethod = <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  &#125;;</span><br><span class="line">  myModule.anotherPublicMethod = <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> myModule; <span class="comment">// returns the Object with public methods</span></span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line"><span class="comment">// usage</span></span><br><span class="line">Module.publicMethod();</span><br></pre></td></tr></table></figure></p>
<p>一个整洁的命名规法是用 ‘_’ 开头命名私有方法, 这可以直观的帮你区分私有和公共方法 :<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Module = (<span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> _privateMethod = <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">var</span> publicMethod = <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  &#125;;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure></p>
<p>我们可以返回一个匿名的对象帮助我们通过对象的方式简单的访问一个功能引用.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Module = (<span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> _privateMethod = <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">var</span> publicMethod = <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    publicMethod: publicMethod,</span><br><span class="line">    anotherPublicMethod: anotherPublicMethod</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure></p>
<p>Happy scoping !</p>
  
	</div>
		<footer class="article-footer clearfix">
<div class="article-catetags">


</div>



	<div class="article-share" id="share">
	
	  <div data-url="http://ittce.github.io/blog/2015/05/07/javascripScope/" data-title="[译]你该知道的javascript作用域 (javascript scope) | ittce blog" data-tsina="null" class="share clearfix">
	  </div>
	
	</div>


</footer>

   	       
	</article>
	
<nav class="article-nav clearfix">
 
 <div class="prev" >
 <a href="/blog/2015/05/07/useVSCode/" title="使用Visual Studio code">
  <strong>上一篇：</strong><br/>
  <span>
  使用Visual Studio code</span>
</a>
</div>


</nav>

	
<section id="comments" class="comment">
	<div class="ds-thread" data-thread-key="2015/05/07/javascripScope/" data-title="[译]你该知道的javascript作用域 (javascript scope)" data-url="http://ittce.github.io/blog/2015/05/07/javascripScope/"></div>
</section>


</div>  
      <div class="openaside"><a class="navbutton" href="#" title="顯示側邊欄"></a></div>

  <div id="toc" class="toc-aside">
  <strong class="toc-title">文章目錄</strong>
 
 <ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#什么是作用域_?"><span class="toc-number">1.</span> <span class="toc-text">什么是作用域 ?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#什么是全局作用域_?"><span class="toc-number">2.</span> <span class="toc-text">什么是全局作用域 ?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#什么是局部作用域_?"><span class="toc-number">3.</span> <span class="toc-text">什么是局部作用域 ?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#函数作用域"><span class="toc-number">4.</span> <span class="toc-text">函数作用域</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#词法作用域(_Lexical_scope_)"><span class="toc-number">5.</span> <span class="toc-text">词法作用域( Lexical scope )</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#作用域链"><span class="toc-number">6.</span> <span class="toc-text">作用域链</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#闭包"><span class="toc-number">7.</span> <span class="toc-text">闭包</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#作用域_和_this"><span class="toc-number">8.</span> <span class="toc-text">作用域 和 this</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#使用_apply(),_call(),_bind()_修改作用域"><span class="toc-number">9.</span> <span class="toc-text">使用 apply(), call(), bind() 修改作用域</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#call()_&&_apply()"><span class="toc-number">9.1.</span> <span class="toc-text">call() && apply()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#bind()"><span class="toc-number">9.2.</span> <span class="toc-text">bind()</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#私有和公共作用域"><span class="toc-number">10.</span> <span class="toc-text">私有和公共作用域</span></a></li></ol>
 
  </div>

<div id="asidepart">
<div class="closeaside"><a class="closebutton" href="#" title="隱藏側邊欄"></a></div>
<aside class="clearfix">

  

  

  <div class="linkslist">
  <p class="asidetitle">友情鏈接</p>
    <ul>
        
          <li>
            
            	<a href="https://coderq.com" target="_blank" title="一个面向程序员交流分享的新一代社区">码农圈</a>
            
          </li>
        
          <li>
            
            	<a href="http://wuchong.me" target="_blank" title="Jark&#39;s Blog">Jark&#39;s Blog</a>
            
          </li>
        
    </ul>
</div>

  


  <div class="rsspart">
	<a href="/atom.xml" target="_blank" title="rss">RSS 訂閱</a>
</div>

</aside>
</div>
    </div>
    <footer><div id="footer" >
	
	<div class="line">
		<span></span>
		<div class="author"></div>
	</div>
	
	
	<section class="info">
		<p> Hello ,I&#39;m ittce in BeiJing. <br/>
			This is my blog,believe it or not.</p>
	</section>
	 
	<div class="social-font" class="clearfix">
		
		
		<a href="https://github.com/ittce" target="_blank" class="icon-github" title="github"></a>
		
		
		
		
		
		
		
		<a href="https://www.zhihu.com/people/ittce" target="_blank" class="icon-zhihu" title="知乎"></a>
		
		
		
		<a href="mailto:clearfix@sina.com" target="_blank" class="icon-email" title="Email Me"></a>
		
	</div>
			
		

		<p class="copyright">
		Powered by <a href="http://hexo.io" target="_blank" title="hexo">hexo</a> and Theme by <a href="https://github.com/wuchong/jacman" target="_blank" title="Jacman">Jacman</a> © 2015 
		
		<a href="/blog/about" target="_blank" title="ittce">ittce</a>
		
		
		</p>
</div>
</footer>
    <script src="/blog/js/jquery-2.0.3.min.js"></script>
<script src="/blog/js/jquery.imagesloaded.min.js"></script>
<script src="/blog/js/gallery.js"></script>

<script type="text/javascript">
$(document).ready(function(){ 
  $('.navbar').click(function(){
    $('header nav').toggleClass('shownav');
  });
  var myWidth = 0;
  function getSize(){
    if( typeof( window.innerWidth ) == 'number' ) {
      myWidth = window.innerWidth;
    } else if( document.documentElement && document.documentElement.clientWidth) {
      myWidth = document.documentElement.clientWidth;
    };
  };
  var m = $('#main'),
      a = $('#asidepart'),
      c = $('.closeaside'),
      o = $('.openaside');
  c.click(function(){
    a.addClass('fadeOut').css('display', 'none');
    o.css('display', 'block').addClass('fadeIn');
    m.addClass('moveMain');
  });
  o.click(function(){
    o.css('display', 'none').removeClass('beforeFadeIn');
    a.css('display', 'block').removeClass('fadeOut').addClass('fadeIn');      
    m.removeClass('moveMain');
  });
  $(window).scroll(function(){
    o.css("top",Math.max(80,260-$(this).scrollTop()));
  });
  
  $(window).resize(function(){
    getSize(); 
    if (myWidth >= 1024) {
      $('header nav').removeClass('shownav');
    }else{
      m.removeClass('moveMain');
      a.css('display', 'block').removeClass('fadeOut');
      o.css('display', 'none');
      
      $('#toc.toc-aside').css('display', 'none');
        
    }
  });
});
</script>

<script type="text/javascript">
$(document).ready(function(){ 
  var ai = $('.article-content>iframe'),
      ae = $('.article-content>embed'),
      t  = $('#toc'),
      ta = $('#toc.toc-aside'),
      o  = $('.openaside'),
      c  = $('.closeaside');
  if(ai.length>0){
    ai.wrap('<div class="video-container" />');
  };
  if(ae.length>0){
   ae.wrap('<div class="video-container" />');
  };
  c.click(function(){
    ta.css('display', 'block').addClass('fadeIn');
  });
  o.click(function(){
    ta.css('display', 'none');
  });
  $(window).scroll(function(){
    ta.css("top",Math.max(140,320-$(this).scrollTop()));
  });
});
</script>


<script type="text/javascript">
$(document).ready(function(){ 
  var $this = $('.share'),
      url = $this.attr('data-url'),
      encodedUrl = encodeURIComponent(url),
      title = $this.attr('data-title'),
      tsina = $this.attr('data-tsina'),
      description = $this.attr('description');
  var html = [
  '<a href="#" class="overlay" id="qrcode"></a>',
  '<div class="qrcode clearfix"><span>扫描二维码分享到微信朋友圈</span><a class="qrclose" href="#nothing"></a><strong>Loading...Please wait</strong><img id="qrcode-pic" data-src="http://s.jiathis.com/qrcode.php?url=' + encodedUrl + '"/></div>',
  '<a href="https://www.facebook.com/sharer.php?u=' + encodedUrl + '" class="article-share-facebook" target="_blank" title="Facebook"></a>',
  '<a href="https://twitter.com/intent/tweet?url=' + encodedUrl + '" class="article-share-twitter" target="_blank" title="Twitter"></a>',
  '<a href="#qrcode" class="article-share-qrcode" title="微信"></a>',
  '<a href="http://widget.renren.com/dialog/share?resourceUrl=' + encodedUrl + '&srcUrl=' + encodedUrl + '&title=' + title +'" class="article-share-renren" target="_blank" title="人人"></a>',
  '<a href="http://service.weibo.com/share/share.php?title='+title+'&url='+encodedUrl +'&ralateUid='+ tsina +'&searchPic=true&style=number' +'" class="article-share-weibo" target="_blank" title="微博"></a>',
  '<span title="Share to"></span>'
  ].join('');
  $this.append(html);
  $('.article-share-qrcode').click(function(){
    var imgSrc = $('#qrcode-pic').attr('data-src');
    $('#qrcode-pic').attr('src', imgSrc);
    $('#qrcode-pic').load(function(){
        $('.qrcode strong').text(' ');
    });
  });
});     
</script>



<script type="text/javascript">
  var duoshuoQuery = {short_name:"ittce"};
  (function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0] 
    || document.getElementsByTagName('body')[0]).appendChild(ds);
  })();
</script> 







<link rel="stylesheet" href="/blog/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/blog/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
$(document).ready(function(){ 
  $('.article-content').each(function(i){
    $(this).find('img').each(function(){
      if ($(this).parent().hasClass('fancybox')) return;
      var alt = this.alt;
      if (alt) $(this).after('<span class="caption">' + alt + '</span>');
      $(this).wrap('<a href="' + this.src + '" title="' + alt + '" class="fancybox"></a>');
    });
    $(this).find('.fancybox').each(function(){
      $(this).attr('rel', 'article' + i);
    });
  });
  if($.fancybox){
    $('.fancybox').fancybox();
  }
}); 
</script>



<!-- Analytics Begin -->





<!-- Analytics End -->

<!-- Totop Begin -->

	<div id="totop">
	<a title="返回頂部"><img src="/blog/img/scrollup.png"/></a>
	</div>
	<script src="/blog/js/totop.js"></script>

<!-- Totop End -->

<!-- MathJax Begin -->
<!-- mathjax config similar to math.stackexchange -->


<!-- MathJax End -->

<!-- Tiny_search Begin -->

<!-- Tiny_search End -->

  </body>
</html>
